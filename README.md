# Amazon_sales_DataAnalysis
 In-depth analysis of Amazon sales data using SQL Server

# amazon_sales_analysis
 This project provides an in-depth analysis of Amazon sales data using SQL Server. It covers various business insights, including revenue trends, customer behavior, order analysis, and inventory management. The dataset consists of multiple tables such as orders, customers, products, and payments.

 ## **Project Overview**

I have worked on analyzing a dataset of over 20,000 sales records from an Amazon-like e-commerce platform. This project involves extensive querying of customer behavior, product performance, and sales trends using mysql server. Through this project, I have tackled various SQL problems, including revenue analysis, customer segmentation, and inventory management.

The project also focuses on data cleaning, handling null values, and solving real-world business problems using structured queries.

---

## **Task: Data Cleaning**

I cleaned the dataset by:
- **Removing duplicates**: Duplicates in the customer and order tables were identified and removed.
- **Handling missing values**: Null values in critical fields (e.g., customer address, payment status) were either filled with default values or handled using appropriate methods.

---

## **Handling Null Values**

Null values were handled based on their context:
- **Customer addresses**: Missing addresses were assigned default placeholder values.
- **Payment statuses**: Orders with null payment statuses were categorized as “Pending.”
- **Shipping information**: Null return dates were left as is, as not all shipments are returned.

---

## **Objective**

The primary objective of this project is to showcase SQL proficiency through complex queries that address real-world e-commerce business challenges. The analysis covers various aspects of e-commerce operations, including:
- Customer behavior
- Sales trends
- Inventory management
- Payment and shipping analysis
- Forecasting and product performance
  

---

```sql
-- SQL PROBLEMS BASED ON THE AMAZON_SALES_ANALYSIS

/*
1. Top Selling Products
Query the top 10 products by total sales value.
Challenge: Include product name, total quantity sold, and total sales value.
*/

select * from products;
select * from order_items;
select * from orders;

select top 10
      p.product_name, 
	  oi.product_id , 
	  sum(quantity * price_per_unit) as total_price,
	  count(o.order_id) as total_orders
from order_items oi
inner join orders o on o.order_id = oi.order_id
inner join products p on p.product_id = oi. product_id
group by p.product_name, oi.product_id
order by total_price desc;

/*
2. Revenue by Category
Calculate total revenue generated by each product category.
Challenge: Include the percentage contribution of each category to total revenue.
*/

with cte as 
(select c.category_id, c.category_name,
       sum(oi.quantity * oi.price_per_unit) as total_sal_pCat,
	   (select sum(quantity * price_per_unit) from order_items) as total_sales
from category c inner join products p
on c.category_id = p.category_id
inner join order_items oi
on oi.product_id = p.product_id
group by c.category_id, c.category_name
)
select cte.category_id, cte.category_name,
       round((total_sal_pCat * 100 / total_sales),2) as total_contribution
from cte 
order by total_contribution desc

/*
3. Average Order Value (AOV)
Compute the average order value for each customer.
Challenge: Include only customers with more than 5 orders.
*/

select cus.customer_id, 
       concat(first_name,' ',last_name) as full_name,
	   count(distinct o.order_id) as count_of_orders,
	   round(sum(quantity * price_per_unit)/
	   count(distinct o.order_id),2) as AOV
from customers cus
inner join orders o on cus.customer_id = o.customer_id
inner join order_items oi on oi.order_id = o.order_id
group by cus.customer_id,concat(first_name,' ',last_name)
having count(distinct o.order_id) > 5
order by customer_id

/*
4. Customers with No Purchases
Find customers who have registered but never placed an order.
Challenge: List customer details and the time since their registration.
*/

select * from customers;
select * from orders;

select cus.customer_id, o.customer_id,
       concat(first_name,' ',last_name) as full_name
from customers cus 
left join orders o
on cus.customer_id = o.customer_id
where o.customer_id is null
order by cus.customer_id;

--Another Approach
select * from customers 
where customer_id not in (select 
                    distinct customer_id from orders)

/*
5. Customer Lifetime Value (CLTV)
Calculate the total value of orders placed by each customer over their lifetime.
Challenge: Rank customers based on their CLTV.
*/

select * from customers;
select * from orders;
select * from order_items;

select distinct o.customer_id, 
       concat(first_name,' ',last_name) as full_name,
	   count(o.order_id) as count_of_orders,
       sum(quantity * price_per_unit) as CLTV,
	   DENSE_RANK() over(order by sum(quantity * price_per_unit) desc) as Rank
from customers cus 
inner join orders o on cus.customer_id = o.customer_id
inner join order_items oi on o.order_id = oi.order_id
group by o.customer_id, concat(first_name,' ',last_name)
order by rank;

/*
6. Inventory Stock Alerts
Query products with stock levels below a certain threshold (e.g., less than 10 units).
Challenge: Include last restock date and warehouse information.
*/

select * from inventory;
select inventory_id, 
       i.product_id, 
	   p.product_name,
	   warehouse_id, 
       stock as current_stock, 
	   last_stock_date 
from inventory i
inner join products p on i.product_id = p.product_id
where stock < 10;

/*
7. Payment Success Rate 
Calculate the percentage of successful payments across all orders.
Challenge: Include breakdowns by payment status (e.g., failed, pending).
*/

select * from payments;

select payment_status, count(*) as payment_count,
       cast(count(*) as numeric) / 
	                 cast ((select count(*) from payments) as numeric) * 100 as pay_percentage
from payments
group by payment_status
order by payment_count desc;

/*
8. Top Performing Sellers
Find the top 5 sellers based on total sales value.
Challenge: Include both successful and failed orders, and display their percentage of successful orders.
*/
select * from sellers;
select * from orders;
select * from order_items;

with top_sellers as 
(select top 5 o.seller_id, 
             s.seller_name, 
             sum(quantity * price_per_unit) as total_sales
from sellers s
inner join orders o on s.seller_id = o.seller_id
inner join order_items oi on o.order_id = oi.order_id
group by o.seller_id, s.seller_name
order by total_sales desc
),
seller_status as
(
select o.seller_id,
       ts.seller_name,
       o.order_status,
	   count(*) as total_orders
from orders o 
inner join top_sellers ts on o.seller_id = ts.seller_id
where order_status not in ('Inprogress','Returned')
group by o.seller_id, ts.seller_name, o.order_status
)
select os.seller_id,
       os.seller_name,
       sum(case when order_status = 'Completed' then total_orders else 0 end) as completed_orders, 
	   sum(case when order_status = 'Cancelled' then total_orders else 0 end) as cancelled_orders, 
	   sum(total_orders) as total_orders,
	   round(sum(cast(case when order_status = 'Completed' then total_orders else 0 end as numeric)) / 
	                                                             sum(cast(total_orders as numeric)) * 100,2) as percentage_successful_orders
from seller_status os
group by os.seller_id, os.seller_name

/*
9. Most Returned Products
Query the top 10 products by the number of returns.
Challenge: Display the return rate as a percentage of total units sold for each product.
*/

select * from orders;
select * from products;
select * from order_items;

select p.product_id,
       p.product_name,
	   count(*) as total_orders,
       sum(case when order_status = 'Returned' then 1 else 0 end) as Returned_orders,
	   sum(cast(case when order_status = 'Returned' then 1 else 0 end as numeric))/cast(count(*) as numeric)* 100 as Returned_percentage
from orders o
inner join order_items oi on o.order_id = oi.order_id
inner join products p on oi.product_id = p.product_id
group by p.product_id, p.product_name
order by Returned_percentage desc;


/*
10. Inactive Sellers
Identify sellers who haven’t made any sales in the last 6 months.
Challenge: Show the last sale date and total sales from those sellers.
*/

WITH cte1 -- as these sellers has not done any sale in last 6 month
AS
(SELECT * FROM sellers
WHERE seller_id NOT IN (SELECT seller_id FROM orders WHERE order_date >= DATEADD(MONTH, -6, GETDATE()))
)
SELECT 
       o.seller_id,
       MAX(o.order_date) as last_sale_date,
       MAX(quantity * price_per_unit) as last_sale_amount
FROM orders as o
inner join cte1 ON cte1.seller_id = o.seller_id
inner join order_items as oi on o.order_id = oi.order_id
GROUP BY o.seller_id

/*
11. Revenue by Shipping Provider
Calculate the total revenue handled by each shipping provider.
Challenge: Include the total number of orders handled and the average delivery time for each provider.
*/
SELECT * FROM shipping;

SELECT 
	s.shipping_providers,
	COUNT(o.order_id) as order_handled,
	SUM(quantity * price_per_unit) as total_sale,
	COALESCE(AVG(datediff(day,s.shipping_date,s.return_date)),0) as average_days
FROM orders as o
inner join order_items as oi on oi.order_id = o.order_id
inner join shipping as s on s.order_id = o.order_id
GROUP BY s.shipping_providers;

/*
12. Top 10 product with highest decreasing revenue ratio compare to last year(2022) and current_year(2023)
Challenge: Return product_id, product_name, category_name, 2022 revenue and 2023 revenue decrease ratio at end Round the result
Note: Decrease ratio = cr-ls/ls* 100 (cs = current_year ls=last_year)
*/

WITH last_year_sale AS (
    SELECT 
        p.product_id,
        p.product_name,
        SUM(oi.quantity * oi.price_per_unit) AS revenue
    FROM orders AS o
    inner join order_items AS oi ON oi.order_id = o.order_id
    inner join products AS p ON p.product_id = oi.product_id
    WHERE YEAR(o.order_date) = 2022
    GROUP BY p.product_id, p.product_name
),
current_year_sale AS (
    SELECT 
        p.product_id,
        p.product_name,
        SUM(oi.quantity * oi.price_per_unit) AS revenue
    FROM orders AS o
    inner join order_items AS oi ON oi.order_id = o.order_id
    inner join products AS p ON p.product_id = oi.product_id
    WHERE YEAR(o.order_date) = 2023
    GROUP BY p.product_id, p.product_name
)
SELECT TOP 10
    cs.product_id,
    ls.revenue AS last_year_revenue,
    cs.revenue AS current_year_revenue,
    ls.revenue - cs.revenue AS rev_diff,
    ROUND(CAST((cs.revenue - ls.revenue) AS NUMERIC) / CAST(ls.revenue AS NUMERIC) * 100, 2)AS revenue_dec_ratio
FROM last_year_sale AS ls
inner join current_year_sale AS cs ON ls.product_id = cs.product_id
WHERE ls.revenue > cs.revenue
ORDER BY revenue_dec_ratio DESC;
```sql

## **Learning Outcomes**

This project enabled me to:
- Design and implement a normalized database schema.
- Clean and preprocess real-world datasets for analysis.
- Use advanced SQL techniques, including window functions, subqueries, and joins.
- Conduct in-depth business analysis using SQL.
- Optimize query performance and handle large datasets efficiently.

---

## **Conclusion**

This advanced SQL project successfully demonstrates my ability to solve real-world e-commerce problems using structured queries. From improving customer retention to optimizing inventory and logistics, the project provides valuable insights into operational challenges and solutions.

By completing this project, I have gained a deeper understanding of how SQL can be used to tackle complex data problems and drive business decision-making.
